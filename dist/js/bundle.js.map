{"version":3,"file":"bundle.js","mappings":";;;;;;;;;;;;;;AAAA;AACA;AACA,2CAA2C;AAC3C;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,wDAAwD;AACxD,4DAA4D;AAC5D;AACA,iCAAiC;AACjC,4CAA4C;AAC5C,oEAAoE;AACpE,2CAA2C;AAC3C;AACA;AACA,gFAAgF;AAChF;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,yEAAyE;AACzE;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,4DAA4D;AAC5D;AACA,iDAAiD;AACjD,oDAAoD;AACpD;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA,qCAAqC;AACrC;AACA,WAAW;AACX;AACA,+CAA+C;AAC/C,uBAAuB;AACvB,SAAS;AACT,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C;AAC/C,sDAAsD;AACtD;AACA,8CAA8C;AAC9C,uCAAuC;AACvC,gDAAgD;AAChD,UAAU;AACV,uCAAuC;AACvC;AACA,2CAA2C;AAC3C;AACA,mCAAmC;AACnC;AACA;AACA,kCAAkC;AAClC;AACA;AACA,+BAA+B;AAC/B;AACA;AACA;AACA,qBAAqB;AACrB,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iEAAe,IAAI;;;;;;;;;;;;;;;ACvHgC;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA,0BAA0B,SAAS;AACnC,8CAA8C,WAAW;AACzD,4CAA4C,WAAW;AACvD;AACA;AACA;AACA,wDAAwD,WAAW;AACnE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,gCAAgC;AAC1D;AACA,YAAY;AACZ,UAAU;AACV;AACA;AACA;AACA;AACA;AACA,OAAO,+DAAW;AAClB;AACA,yBAAyB,gCAAgC,OAAO;AAChE;AACA,SAAS;AACT,OAAO;AACP;AACA;AACA,iEAAe,KAAK;;;;;;;;;;;;;;;;ACpE4B;AACA;AAChD;AACA;AACA;AACA,2DAA2D;AAC3D;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA,uBAAuB;AACvB;AACA,CAAC,GAAG;AACJ;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B,0CAA0C;AAC1C,wBAAwB;AACxB,yDAAyD;AACzD,yCAAyC;AACzC,qDAAqD;AACrD;AACA;AACA;AACA,OAAO;AACP,2DAA2D;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C;AAC5C;AACA,KAAK,4DAAQ;AACb,qBAAqB;AACrB,6BAA6B;AAC7B,4CAA4C;AAC5C,kCAAkC;AAClC,MAAM,gBAAgB;AACtB;AACA,MAAM,mBAAmB;AACzB;AACA,MAAM;AACN;AACA,GAAG;AACH;AACA;AACA,oCAAoC;AACpC,oEAAoE;AACpE;AACA;AACA,EAAE,iDAAS;AACX;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,QAAQ;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI,kDAAU;AACd,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC;AACvC;AACA;AACA;AACA,iEAAe,KAAK;;;;;;;;;;;;;;;;ACrGpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC;AAClC;AACA;AACA;AACA;AACA;AACA,qDAAqD;AACrD;AACA;AACA;AACA;AACA,oFAAoF;AACpF;AACA,SAAS;AACT;AACA;AACA;AACA,2CAA2C;AAC3C,+EAA+E;AAC/E,qCAAqC;AACrC;AACA;AACA,GAAG;AACH;AACA;AACA,6CAA6C;AAC7C;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mDAAmD;AACnD;AACA,iEAAiE;AACjE,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA,iEAAe,KAAK,EAAC;AACF;;;;;;;;;;;;;;;AC7EnB,iBAAiB,qFAAqF;AACtG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6DAA6D;AAC7D;AACA;AACA;AACA;AACA,mBAAmB;AACnB,gBAAgB;AAChB;AACA;AACA;AACA;AACA,0BAA0B;AAC1B,4BAA4B,cAAc;AAC1C,8BAA8B,WAAW;AACzC,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qDAAqD;AACrD;AACA;AACA,oCAAoC;AACpC,yCAAyC;AACzC;AACA,yCAAyC;AACzC;AACA;AACA,2BAA2B;AAC3B,6BAA6B;AAC7B,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B;AAC1B;AACA,eAAe,kBAAkB;AACjC;AACA,4CAA4C;AAC5C,4BAA4B;AAC5B;AACA;AACA,kBAAkB;AAClB;AACA;AACA,+BAA+B;AAC/B;AACA;AACA;AACA,4CAA4C;AAC5C,gEAAgE;AAChE;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB,IAAI;AACJ,sCAAsC;AACtC;AACA,+CAA+C,OAAO,MAAM;AAC5D;AACA;AACA;AACA;AACA,qCAAqC;AACrC,mBAAmB;AACnB,IAAI,MAAM;AACV,iBAAiB;AACjB;AACA;AACA;AACA,CAAC;AACD;AACA;AACA,wBAAwB;AACxB;AACA,4DAA4D;AAC5D,IAAI;AACJ,sCAAsC;AACtC;AACA,+CAA+C,OAAO,OAAO;AAC7D;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA,CAAC;AACD;AACA,sBAAsB;AACtB;AACA;AACA;AACA,4BAA4B;AAC5B;AACA,mDAAmD,OAAO;AAC1D;AACA;AACA;AACA,GAAG;AACH,CAAC;AACD;AACA;AACA,iEAAe,MAAM;;;;;;;;;;;;;;AC5HrB;AACA;AACA;AACA,6DAA6D;AAC7D;AACA;AACA,oCAAoC;AACpC;AACA,iDAAiD;AACjD;AACA,OAAO,GAAG;AACV;AACA;AACA,OAAO,IAAI;AACX;AACA;AACA,sCAAsC;AACtC,oDAAoD;AACpD;AACA;AACA;AACA,MAAM;AACN;AACA,uBAAuB;AACvB;AACA,uDAAuD;AACvD,mCAAmC;AACnC,uEAAuE;AACvE,uCAAuC;AACvC,oCAAoC;AACpC;AACA,iCAAiC;AACjC;AACA;AACA,WAAW;AACX;AACA,KAAK;AACL;AACA;AACA,iEAAe,IAAI;;;;;;;;;;;;;;ACvCnB;AACA;AACA;AACA;AACA;AACA;AACA,oDAAoD;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC;AAChC;AACA,wBAAwB,IAAI;AAC5B,WAAW;AACX;AACA;AACA;AACA,8CAA8C;AAC9C;AACA;AACA;AACA;AACA;AACA,4DAA4D;AAC5D,yBAAyB;AACzB;AACA;AACA,gDAAgD;AAChD,4CAA4C;AAC5C;AACA;AACA;AACA;AACA;AACA,4BAA4B;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iEAAe,KAAK;;;;;;;;;;;;;;;ACjDpB,wCAAwC;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,OAAO,EAAE;AACT;AACA,+BAA+B;AAC/B;AACA;AACA;AACA,uCAAuC;AACvC;AACA;AACA,qCAAqC;AACrC;AACA,0CAA0C,IAAI,UAAU,WAAW;AACnE;AACA;AACA;AACA;AACA,EAAmB;AACnB,EAAsB;AACtB;AACA;AACA;;;;;;UCjCA;UACA;;UAEA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;;UAEA;UACA;;UAEA;UACA;UACA;;;;;WCtBA;WACA;WACA;WACA;WACA,yCAAyC,wCAAwC;WACjF;WACA;WACA;;;;;WCPA;;;;;WCAA;WACA;WACA;WACA,uDAAuD,iBAAiB;WACxE;WACA,gDAAgD,aAAa;WAC7D;;;;;;;;;;;;;;;;;;ACNa;AACsB;AACC;AACC;AACA;AACA;AACE;AACJ;AACS;AAC5C;AACA;AACA;AACA,oDAAoD;AACpD;AACA,0CAA0C,yDAAS;AACnD,yDAAI;AACJ,0DAAK;AACL,0DAAK;AACL,0DAAK;AACL,0DAAK;AACL,2DAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD,yDAAI;AACJ,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,gCAAgC;AACpD;AACA;AACA;AACA;AACA,qBAAqB,IAAI,UAAU,OAAO;AAC1C,6CAA6C,MAAM;AACnD,2CAA2C,MAAM;AACjD;AACA;AACA;AACA;AACA,uDAAuD,MAAM;AAC7D;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","sources":["webpack://foodsite/./src/js/modules/calc.js","webpack://foodsite/./src/js/modules/cards.js","webpack://foodsite/./src/js/modules/forms.js","webpack://foodsite/./src/js/modules/modal.js","webpack://foodsite/./src/js/modules/slider.js","webpack://foodsite/./src/js/modules/tabs.js","webpack://foodsite/./src/js/modules/timer.js","webpack://foodsite/./src/js/services/services.js","webpack://foodsite/webpack/bootstrap","webpack://foodsite/webpack/runtime/define property getters","webpack://foodsite/webpack/runtime/hasOwnProperty shorthand","webpack://foodsite/webpack/runtime/make namespace object","webpack://foodsite/./src/js/script.js"],"sourcesContent":["function calc(){\r\n    const result = document.querySelector('.calculating__result span');\r\n    let sex, height, weight, age , ratio ; //ratio коэф активности записан в дата атрибутах в верстке\r\n    \r\n    \r\n    if(localStorage.getItem('sex')){\r\n       sex = localStorage.getItem('sex');\r\n    }else {\r\n      sex = 'female';\r\n      localStorage.setItem('sex', 'female');\r\n    }\r\n    \r\n    \r\n    if(localStorage.getItem('ratio')){\r\n      ratio = localStorage.getItem('ratio');\r\n    }else {\r\n     ratio = 1.375;\r\n     localStorage.setItem('ratio', 1.375);\r\n    }\r\n    \r\n    \r\n    function initLocalSettings(selector, activeClass) { //функция для обработки значений с локального хранилища и смены класса активности под элементы согласно данных пользовательяс прошлого захода на сайт\r\n      const elements = document.querySelectorAll(selector); //получаем элементы со страницы\r\n    \r\n      elements.forEach(elem => { //перебираем псевдомассив\r\n        elem.classList.remove(activeClass); //перебираем каждый элемент и удаляем у каждого класс активности\r\n        if(elem.getAttribute('id') === localStorage.getItem('sex')){//условие для верхних блоков с активностью если в элементе содержится айди и в локальном хранилище будет равно полу\r\n          elem.classList.add(activeClass); //то навешиваем на этот элемент класс активности(в локальном хранилище будет указано на каком поле пользователь)\r\n        }\r\n    \r\n        if(elem.getAttribute('data-ratio') === localStorage.getItem('ratio')) { // условие для нижних блоков с активностью\r\n          elem.classList.add(activeClass);\r\n    \r\n        }\r\n      });\r\n    }\r\n    \r\n    initLocalSettings('#gender div', 'calculating__choose-item_active'); // gender div означает что мы обращаемся к блокам див внутри айди гендер\r\n    initLocalSettings('.calculating__choose_big div', 'calculating__choose-item_active');\r\n    \r\n    function calcTotal() {\r\n      if(!sex || !height || !weight || !age || !ratio) {\r\n        result.textContent = '____';\r\n        return; //пишем реторн для прерывания функции \r\n      }\r\n      if(sex === 'female'){\r\n        //используем Math.round для округления значения \r\n        result.textContent = Math.round((447.6 + (9.2 * weight) + (3.1 * height) - (4.3 * age)) * ratio);\r\n      }else {\r\n        result.textContent = Math.round((88.6 + (13.4* weight) + (4.8 * height) - (5.7 * age)) * ratio);\r\n      }\r\n    }\r\n    calcTotal(); //вызываем чтобы значение заданное версткой поменялоссьь на ____\r\n    \r\n    \r\n    function getStaticInformation(selector, activeClass){\r\n      const elements = document.querySelectorAll(selector); // получаем псевдомассив с нашими элементами\r\n      elements.forEach(elem => {\r\n        elem.addEventListener( 'click', (e) => { //на каждый элемент навешиваем обработчик событий\r\n          if(e.target.getAttribute('data-ratio')) { //если наш таргет на странице будет содержать атрибут 'data-ratio' то присваиваем переменной ratio \r\n            //значение 'data-ratio' а именно числов в это атрибуте\r\n            ratio = +e.target.getAttribute('data-ratio');\r\n            localStorage.setItem('ratio', +e.target.getAttribute('data-ratio'));\r\n          } else {\r\n            sex = e.target.getAttribute('id');\r\n            localStorage.setItem('sex', e.target.getAttribute('id'));\r\n          }\r\n       \r\n          elements.forEach(elem => { // здесь мы удаляем класс активности на всех элементаъ\r\n            elem.classList.remove(activeClass);\r\n          });\r\n      \r\n          e.target.classList.add(activeClass); //добавляем активность при клике на элемент\r\n          calcTotal(); //вызываем для обновления значения\r\n        });\r\n      });\r\n    \r\n     \r\n    \r\n    }\r\n    //вызываем две функции для разных наших блоков\r\n    //можно было и написать две схожие функции но мы с помощью условий уменьшили код и теперь наша функция многофункциональна \r\n    getStaticInformation('#gender div', 'calculating__choose-item_active');\r\n    getStaticInformation('.calculating__choose_big div', 'calculating__choose-item_active');\r\n    \r\n    \r\n    function getDynamicInformation(selector) { // пишем функцию для обработки значений полученных с инпутов со страницу\r\n      const input = document.querySelector(selector); //получаем инпут со страницы\r\n    \r\n      input.addEventListener('input', () => { //навешиваем обработчик на инпут\r\n        if(input.value.match(/\\D/g)) { // ставим условие с помощью регулярного выражения что если значения инпута будет НЕ число и глобально на всякий случай\r\n          input.style.border = '1px solid red'; // обводим инпут красным\r\n        } else {\r\n          input.style.border = 'none'; //если все хорошо обнуляем стиль инпута\r\n        }\r\n        switch(input.getAttribute('id')) { //свич для обработки каждого значение свич работат с айди инпута\r\n          case 'height':\r\n            height = +input.value; //присваеваем значения инпута если атрибут айди будет рост\r\n            break;\r\n          case 'weight':\r\n            weight = +input.value;//присваеваем значения инпута если атрибут айди будет вес\r\n            break;\r\n          case 'age':\r\n            age = +input.value;//присваеваем значения инпута если атрибут айди будет возраст\r\n            break;\r\n    \r\n        }\r\n        calcTotal(); //вызываем для обнавления значения\r\n      });\r\n    }\r\n    \r\n    //вызываем фунцкцю для каждого инпута\r\n    getDynamicInformation('#height'); \r\n    getDynamicInformation('#weight');\r\n    getDynamicInformation('#age');\r\n    \r\n}\r\n\r\n\r\nexport default calc;","import { getResource } from \"../services/services\";\r\n\r\n\r\nfunction cards(){\r\n    class ItemStructure  {\r\n        constructor(src, alt, title, descr,price, parentSelector, ...classes) {\r\n          this.src = src;\r\n          this.alt = alt;\r\n          this.title = title;\r\n          this.descr = descr;\r\n          this.price = price;\r\n          this.parent = document.querySelector(parentSelector);\r\n          this.classes = classes ;\r\n        }\r\n        createStructure(){\r\n          let div = document.createElement('div');\r\n          this.div = 'menu__item';\r\n          if(this.classes.length === 0){\r\n            div.classList.add(this.div);\r\n          } else {\r\n            this.classes.forEach( className => div.classList.add(className));\r\n          }\r\n      \r\n          div.innerHTML = `\r\n            <img src = \"${this.src}\"></img> \r\n            <h3 class=\"menu__item-subtitle\">${this.title}</h3>\r\n            <div class=\"menu__item-descr\">${this.descr}</div>\r\n            <div class=\"menu__item-divider\"></div>\r\n            <div class=\"menu__item-price\">\r\n                  <div div class=\"menu__item-cost\">Цена:</div>\r\n                  <div class=\"menu__item-total\"><span>${this.price}</span> $/день</div>\r\n                </div>\r\n          \r\n          `;\r\n          this.parent.append(div);\r\n        }\r\n    \r\n    }\r\n    \r\n\r\n    \r\n    \r\n    \r\n    \r\n    \r\n    // getResource(' http://localhost:3000/menu')//тут мы обращаемся к фунции гет ресурс получаем с сервера данные после обрабатывает ответ от сервера(это промисс)\r\n    // //с помощью  зена зену даем аргумент дату так как с сервера мы поулучаем меню которое является массивом применяем \r\n    // //фор ич и тут интересное с помощью этого синтаксиса проводим деструктуризацию обьекта(внутри массива у нас лежит обьект)\r\n    // //и достаем img,altimg, title, descr, price следующие свойства после чего их мы добавляем\r\n    // //в нащ класс-конструктор и вызываем на классе конструкторе метод createStructure();\r\n    //   .then(data => {\r\n    //     data.forEach(({img,altimg, title, descr, price}) => {\r\n    //       new ItemStructure(img,altimg, title, descr, price,'.menu .container').createStructure();\r\n    //     });\r\n    //   });\r\n    \r\n      //есть еще спосо с помощью сторонней библиотеки аксиос заранее подключаем библиотеку аксиос\r\n      //после чего мы так и пишем аксиос и т.д\r\n      //аксиос тоже промисс в чем плюс в том что аксиос автоматически трансформирует в джейсон формат\r\n      //также \r\n       getResource('http://localhost:3000/menu')\r\n       .then(data => {\r\n          data.forEach(({img,altimg, title, descr, price}) => { //мы обрашаемся дата.дата потому что аксиос сначал возвращает обьект в котором как свойство лежат наши данные\r\n              new ItemStructure(img,altimg, title, descr, price,'.menu .container').createStructure();\r\n        });\r\n      });\r\n}\r\n\r\nexport default cards;","import { closeModal, showModal } from \"./modal\";\r\nimport { postData } from \"../services/services\";\r\n\r\n\r\nfunction forms(formSelector, modalTimerId){\r\n    const forms = document.querySelectorAll(formSelector); //ПОЛУЧАЕМ формы\r\n\r\nconst message = { //обьявляем обьект сообщений процесса отправки на сервер данных\r\n  loading: 'icons/spinner.svg',\r\n  success: 'Thaks.We will connect you soon',\r\n  failure:'Thats bad...'\r\n};\r\n\r\nforms.forEach(item =>{ //для каждой формы применяем функцию\r\n bindPostData(item);\r\n}); //перед ТЕСТИРОВАНИЕ СБРОСИТЬ КЕШ НА САЙТЕ SHIFT+ F5\r\n\r\n\r\n\r\n\r\n\r\nfunction bindPostData(form){ //функция для отправки формы на сервер\r\n  form.addEventListener('submit', (e)=> { // submit событие отправки формы\r\n    e.preventDefault(); //сбпрос стандартной перезагрузки страницы\r\n    const statusMessage = document.createElement('img'); //добавляем сообщения процесса отправки на страницу\r\n    statusMessage.src = message.loading; //атрибут срс равен свойству обьекта меседж который является путем к картинке\r\n    statusMessage.textContent = message.success;     // текст который будет выводится при отправки формы\r\n    statusMessage.style.cssText = ` \r\n      display: block;\r\n      margin: 0 auto;\r\n    `; //правильней конечно просто сделать класс в CSS И потом добавить класс к статус меседж но делали тут как препод\r\n    form.insertAdjacentElement('afterend', statusMessage); // метод вставки элемента в определенно положения элемента то есть читаем так вставить в элемент форм элемент статусМеседж\r\n    //в конце\r\n    \r\n\r\n \r\n     //описываем метод HTTP и файл куда будет поститься данные\r\n     // ОПИСЫВАЕМ ФАЙЛ когда мы используем связку XMLHttpRequest и FormData заголовок НАМ УСТАНАВЛИВАТЬ НЕ НУЖНО ОН УСТАНАВЛИВАЕТСЯ АВТОМАТИЧЕСКИ\r\n    const formData = new FormData(form); //не все данные мы передаем в формате джейсон\r\n    //также можно передавать в формате формДейта также там ключ значение \r\n    //САМОЕ ГЛАВНОЕ ЧТО ПРИ ОБРАБОТКЕ ФОРМ В ФОРМЕ В ВЕРСТКЕ ОБЯЗАЛЬНО ДОЛЖЕН БЫТЬ АТРИБУТ name = ''\r\n    \r\n    \r\n    //==========здесь мы разбираем метод для отправки данных в формате джейсон\r\n    //так как ФОРМ ДАТА нельзя просто так переформатировать в джейсон\r\n    //необходимо перебрать его и запулить в обьект\r\n    const json = JSON.stringify(Object.fromEntries(formData.entries()));\r\n  //в этой строке мы трансформируем нашу формдейту в массив массивов методом ентриес после чего делаем из него\r\n  //обычный обьект методом фроментриес и после чего трансформируем  в джейсон формат методом JSON.stringify\r\n  //получаем переменную джейсон которую передаем в функцию постдата\r\n\r\n    // const json = JSON.stringify(object); // трансформация формДаты в джейсон закоментили потому что в бади мы уже трансформируем обьект\r\n\r\n     postData('http://localhost:3000/requests',json)\r\n     .then(data => { //дата это ответ от сервера в этом промисе мы выводим ответ в консоль\r\n          console.log(data); //Выводим в консоль ответ от сервера\r\n          showThanksModal(message.success); //и запускаем что все хорошо\r\n          statusMessage.remove(); //удаляем спиннер\r\n     }).catch(() => { //кэтч ловит ошибки то есть в случае ошибок делает это лучше всегда писать кэтч на всякий случай\r\n          showThanksModal(message.failure);\r\n     }).finally (() => { //после всех промисов сбарсываем форму\r\n      form.reset();\r\n     });\r\n\r\n  });\r\n}\r\n\r\nfunction showThanksModal(message) { //функция для модернизации модального окна для показывания сообщения вместо формы что форма отправилась\r\n  const prevModalDialog = document.querySelector('.modal__dialog'); //получаем модальное окно\r\n\r\n  prevModalDialog.classList.add('hide');\r\n  showModal('.modal', modalTimerId);\r\n\r\n  const thanksModal = document.createElement('div');\r\n  thanksModal.classList.add('modal__dialog');\r\n  thanksModal.innerHTML = `\r\n    <div class = \"modal__content\">\r\n      <div class =\"modal__close\" data-close >×</div>\r\n      <div class =\"modal__title\">${message}</div>\r\n    </div>\r\n  `;\r\n\r\n  document.querySelector('.modal').append(thanksModal);\r\n\r\n  setTimeout( () => {\r\n    thanksModal.remove();\r\n    prevModalDialog.classList.add('show');\r\n    prevModalDialog.classList.remove('hide');\r\n    closeModal('.modal');\r\n  },4000);\r\n}\r\n\r\nfetch('http://localhost:3000/menu') //здесь с помощью фетча мы просто получим нащу базу данных\r\n// после добавления нашей базы данных с помощью  npx json-server db.json прямо из терминала мы берем\r\n//и копируем наши пути и там мы можем обрашаться напрямую к джейсон структурам\r\n//\r\n    .then(data => data.json())\r\n    // .then(res => console.log(res)); //выведется массив меню\r\n\r\n}\r\n\r\nexport default forms;","'use strcit';\r\nfunction closeModal (modalSelector){ \r\n  const modal = document.querySelector(modalSelector);\r\n  modal.classList.add('hide');\r\n  modal.classList.remove('show');\r\n  document.body.style.overflow = 'visible';\r\n}\r\n\r\nfunction showModal(modalSelector, modalTimerId){\r\n    const modal = document.querySelector(modalSelector);\r\n    modal.classList.add('show');\r\n    modal.classList.remove('hide');\r\n    document.body.style.overflow = 'hidden';\r\n    // console.log(modalTimerId);\r\n    if(modalTimerId){\r\n      clearInterval(modalTimerId);// если пользователь уже открывал модальное окно\r\n    }\r\n\r\n}\r\n\r\n\r\nfunction modal(triggerSelector, modalSelector, modalTimerId){\r\n  function showModal(modalSelector, modalTimerId){\r\n    const modal = document.querySelector(modalSelector);\r\n    modal.classList.add('show');\r\n    modal.classList.remove('hide');\r\n    document.body.style.overflow = 'hidden';\r\n    // console.log(modalTimerId);\r\n    if(modalTimerId){\r\n      clearInterval(modalTimerId);// если пользователь уже открывал модальное окно\r\n    }\r\n\r\n}\r\n\r\n    let  modalCall = document.querySelectorAll(triggerSelector), // в квадратных скобках получение по атрибуту \r\n      modal = document.querySelector(modalSelector); // получаем элементы со страницы\r\n\r\n\r\n\r\n    modalCall.forEach(btn => {\r\n      btn.addEventListener('click', () =>  showModal(modalSelector, modalTimerId)); // создаем тут стрелочную функцию так как нельзя вторым аргументом в обработчик события\r\n      //ставить вызывающейся функцию так как нам надо чтобы она сработала тогкда когда будет клик а не сразу стрелочная функция решает проблему\r\n        });\r\n\r\n\r\n\r\n  modal.addEventListener('click', (e) => { // обработчик события если мы нажимаем вне модального окна\r\n          if(e.target === modal || e.target.getAttribute('data-close') == ''){ //условие закртытия модали если еще и таргет над крестиком\r\n          closeModal(modalSelector); // ХОРОШЕЙ ПРАКТИКОЙ НАПИСАНЯ КОДА ЯВЛЯЕТСЯ ТО ЧТО ЕСЛИ КОД ПОВТОРЯЕТСЯ БОЛЬШЕ ОДНОГО РАЗА ЗНАЧИТ НАДО ЕГО ЗАБИТЬ В ФУНКЦИЮ\r\n}\r\n\r\n  });\r\n\r\n\r\ndocument.addEventListener('keydown', (e) =>{ // обработчик события если мы нажимаем на клавишу ЕСКЕЙП\r\n    if(e.code === 'Escape'){\r\n      closeModal(modalSelector);\r\n    }\r\n});\r\n\r\n\r\n\r\n// Modal\r\n\r\nfunction showModalByScroll(){\r\n    if(window.pageYOffset + document.documentElement.clientHeight >= \r\n      document.documentElement.scrollHeight - 1) { // -1 пиксель это баг браузера технический\r\n        showModal(modalSelector, modalTimerId);\r\n        window.removeEventListener('scroll', showModalByScroll); // для того чтобы один раз когда пользователь долистает до конца больше модалка не вызывалась\r\n      } // условие если  количество прокрученных пикселей по вертикали плюс клиентская высота окна браузера\r\n      //будет больше либо равна длинне скролла то это будет означать что пользователь долистал до конца\r\n\r\n}\r\nwindow.addEventListener('scroll', showModalByScroll);\r\n}\r\n\r\nexport default modal;\r\nexport{closeModal};\r\nexport{showModal};","function slider({container, slide, nextArrow, prevArrow, totalCounter, currentCounter, wrapper, field}){\r\n    const slider = document.querySelector(container),\r\n       current = document.querySelector(currentCounter),\r\n       total = document.querySelector(totalCounter),\r\n       prevSlide = document.querySelector(prevArrow),\r\n       nextSlide = document.querySelector(nextArrow),\r\n       slides = document.querySelectorAll(slide),\r\n       slidesWrapper = document.querySelector(wrapper,),// получаем обертку слайдера\r\n       slidesField = document.querySelector(field),//получаем поле где будут наши слайдеры\r\n       width = window.getComputedStyle(slidesWrapper).width; //получаем ширину слайда занимаемую\r\n       //на экране\r\n\r\n\r\n\r\nlet slideIndex = 1;// обьявляем слайд индекс для слайдов\r\nlet offset = 0; //отступ\r\n\r\n\r\n\r\nfunction addZeroToCount(){\r\n  if(slides.length < 10){ //условие если слайдов меньше 10 подставляем 0 вперед числа\r\n    total.textContent = `0${slides.length}`;\r\n    current.textContent = `0${slideIndex}`;\r\n  }else {\r\n    total.textContent = slides.length;\r\n    current.textContent = slides.length;\r\n  \r\n  }\r\n}\r\nfunction opacityDots() {\r\n  dots.forEach(dot => dot.style.opacity = '50%');\r\n  dots[slideIndex - 1].style.opacity = 1;\r\n }\r\n//====описываем наше поле для слайдов\r\nslidesField.style.width = slides.length * 100 + '%'; //тут мы формируем ширину нашего поля на основании количества\r\n//слайдов количество слайдов умножаем на 100 и добавляем в конце проценты и это будет ширина нашего поля\r\n//делается это для того чтобы мы могли поместить все слайды которые у нас есть на странице во внутрь поля\r\nslidesField.style.display = 'flex'; //устнавливаем флекс чтобы все наши элементы были вряд\r\nslidesField.style.transition = '1s all'; //ставим свойство трансишн которое означает скорость смены слайдов\r\n\r\nslidesWrapper.style.overflow = 'hidden'; //оверфлоу означает что то что не помещается в блок будет скрыто\r\n\r\n\r\nslides.forEach( slide => { //перебериаем кажды слайд\r\n  slide.style.width = width; //перебираем все слайды и устанавливаем каждому слайду ширину одного слайда равную ширине враппера со слайдами\r\n});\r\n\r\nslider.style.position = 'relative';\r\n\r\nconst indicators = document.createElement('ol'), //задаем контейнер для кружочков снизу слайдера\r\n      dots = [];\r\nindicators.classList.add('carousel-indicators');\r\nslider.append(indicators);//добавляем наш кружочек в слайдер\r\n\r\nfor(let i = 0; i <slides.length; i++) {\r\n  const dot = document.createElement('li');\r\n  dot.setAttribute('data-slide-to', i + 1); //добавляем каждому кружку атрибут дата слайд ту и начания с первого(не с нулевого)\r\n  dot.classList.add('dot'); //добавляем ровно столько точек сколько слайдов исходя из цикла\r\n\r\n  indicators.append(dot);\r\n  dots.push(dot); //добавляем кружки в новый массив\r\n}\r\n\r\nfunction deleteNotDigits(str){ // функция по удалению всех не цифр со строки\r\n return +str.replace(/\\D/g, '');\r\n}\r\n\r\nnextSlide.addEventListener('click', () => { //пишем функцию для следующего слайда\r\n  if (offset == deleteNotDigits(width) * (slides.length - 1)){  //если наш отступ будет равен ширине одного слайда \r\n    //в нашей ширине с помощью регулярных выражений удаляем ВСЕ НЕ цифры с нашего выржанием и заменяем на ничего так как не передаем ничего\r\n    //допустим у нас 7 слайдов переменная виз содержит ширину занимаемую врапером на странице к примеру 500 получится  500 * 7 = 3500пикселей\r\n    // +width.slice(0,width.length - 2) унарный плюс для преобразования в число метод слайс для того чтобы оставить только число\r\n    //так как переменная width будет еще содержать буквы PX\r\n    //умноженное на количество слайдов минус 1 это означает что мы долистали до самого конца минус 1 потому что свойство ленгт переводит в человеский язык количство слайдов\r\n    //и нам нужно вернуться в начало\r\n    offset = 0; //устанавливаем отступ на 0  возвращаемся в начало слайдов\r\n  } else {\r\n    offset += deleteNotDigits(width); //каждый раз при клике прибалвяем ширину равную ширине враппера\r\n  }\r\n  slidesField.style.transform = `translateX(-${offset}px)`; //transform позволяет вам поворачивать, масштабировать, \r\n  // наклонять или сдвигать элемент. Оно модифицирует координатное пространство\r\n  //  для CSS визуальной форматируемой модели.\r\n  // translate X означает сместить по оси Х на - офсет минус это сместить влево(на координатной прямой минус слева)\r\n  //то есть будем передвигать прошлый слайд влево и показывать следующий\r\n   if(slideIndex == slides.length) { //если слайд индекс будет равен количеству слайдов\r\n    slideIndex = 1;//возвращаемся в начало\r\n   }else {//если нет\r\n    slideIndex++;//приплюсовываем 1 к слайд индексу\r\n   }\r\n   addZeroToCount();\r\n   opacityDots();\r\n});\r\n\r\nprevSlide.addEventListener('click', () => {\r\n  if ( offset == 0 ){   //когда мы нажимаем на кнопу prev и при этом у нас первый слайд мы перемещаемся\r\n    //в самый конец\r\n     offset = deleteNotDigits(width) * (slides.length - 1); //устанавливаем офсет маскимальное значение пикслей\r\n  } else {\r\n    offset -= deleteNotDigits(width); //если офсет не 0 то от офсет отнимает ширину враппера\r\n  }\r\n  slidesField.style.transform = `translateX(-${offset}px)`;  //перемещаем слайды по оси икс\r\n  if(slideIndex == 1) {\r\n    slideIndex = slides.length;\r\n   }else {\r\n    slideIndex--;\r\n   }\r\n   addZeroToCount();\r\n   opacityDots();\r\n});\r\n\r\ndots.forEach(dot => { //на наши точки делаем функциональность которая при нажатаии\r\n  //будет позволять переключать слайды\r\n  dot.addEventListener('click', (e) => {\r\n      const slideTo = e.target.getAttribute('data-slide-to');\r\n      slideIndex = slideTo; //кликнули на четвертую  точку и соответственно в слйд индекс у нас пойдет 4-ка\r\n      offset = deleteNotDigits(width) * (slideTo - 1);\r\n      slidesField.style.transform = `translateX(-${offset}px)`;\r\n      opacityDots();\r\n      addZeroToCount();\r\n\r\n  });\r\n});\r\n}\r\n\r\nexport default slider;","function tabs(tabsSelector, tabsContetnSelector, tabsParentSelector, activeClass){\r\n    const tabs = document.querySelectorAll(tabsSelector), // получаем наши подписи ПОСТНОЕ СБАЛАНСИРОВАННОЕ И Т.Д.\r\n    tabsContent = document.querySelectorAll(tabsContetnSelector,),// Получаем наши дивы которые содержат в себе картинки с едой и описание в отдельном блоке поверх картинки\r\n    tabsParent = document.querySelector(tabsParentSelector); //получаем оберточный блок для всех нащих табхедер айтемов(для последущего делегирования событий)\r\n\r\n    function hideTabContent () { \r\n      tabsContent.forEach(item => { // перебираем наш псевдомассив и назначаем для каждого элемента класс ХАЙД который дисплэй нон и удаляем от туда класс ШОУ И ФЭЙД ЕСЛИ ОНИ НАЗНАЧЕНЫ(ФЭЙД ЭТО АНИМАЦИЯ)\r\n          item.classList.add('hide');\r\n          item.classList.remove('show', 'fade'); // просто записываем инлайновый стиль для этого элемента скрываем все элементы\r\n\r\n      }); // перебор всех элементов псевдомассива табсконтент для скрытия их с экрана\r\n      tabs.forEach(tab => {\r\n          tab.classList.remove(activeClass);\r\n      });  // функция по удалению класса активности (НИЖНЕГО подчеркивания в наших надписях)\r\n    }\r\n\r\n    function showTabContent (i = 0) { // = 0 это дефолтное значение то есть если функция передается без аргумента по умолчанию будет подставляться 0\r\n      tabsContent[i].classList.add('show', 'fade'); // КЛАССЫ ШОУ ХАЙД У НАС ДОБАВЛЕНЫ В СИ ЭС ЭС НО ИХ НЕТ НА СТРАНИЦЕ НАПРЯМУЮ\r\n      tabsContent[i].classList.remove('hide');\r\n\r\n      tabs[i].classList.add('tabheader__item_active');\r\n    } // эта функция для вывода таба табу будет присваиваться класс ШОУ и ФЭЙД  также подписи сбоку будет нижнее подчеркивание АЙ тут это будет соответсвовать номеру таба\r\n    hideTabContent();\r\n    showTabContent();  //вызов обеих функций для удаления всего лишнего с сайта и чтобы не поплыла верстка\r\n\r\n    tabsParent.addEventListener('click', (event) => {  //используем делегирование событий для тэбспэрент\r\n      const target = event.target; //чтобы каждый раз не писать ивент таргет обьявляем переменную \r\n      if(target && target.classList.contains(tabsSelector.slice(1))) { //если есть таргет и он содержит табхедер__айтем то обьявляем перебор в псевдомассиве табс\r\n          tabs.forEach( (item, i) => { //  метод слайс на таб селектор нужен для того чтобы подставить название селектора без точки\r\n              if (target == item) { // кликнули мы в третий таб начинается перебор и как только  ай =3 и таргет равно трем вызываются две наших функции  \r\n              hideTabContent();\r\n              showTabContent(i); //сюда будет подставлятся номер по порядку перебора\r\n\r\n              }\r\n          });\r\n      }\r\n    });\r\n}\r\n\r\nexport default tabs;","function timer(id, deadline){\r\n    function getTimeRemaining(endtime) {\r\n      const t = Date.parse(endtime) - new Date(), // тоже самое что и new Date() здесь мы получим количеству миллисекунд котороое и будет нашим конечным временем\r\n            days = Math.floor(t / (1000 * 60 * 60 * 24)), // t делим на на скобках(миллисек умножаем на 60 секунд умножаем на 60 минут и 24 часа) и в скобках получается дни\r\n            hours = Math.floor( (t / (1000 * 60 * 60) % 24) ), // Т делим на (милисекунды умнодаем на секунды умножаем на минуты и делим на 24 и в остатке у нас появятся часы которые мы округкляем до целого)\r\n            minutes = Math.floor( (t / 1000 / 60 ) % 60), // получае сначало количество миллисекунд потом количество секунд и количество минут\r\n            seconds = Math.floor( (t / 1000) % 60); // все просто делим на количество миллисекунд и в остатке получаем секунды\r\n        return {\r\n          'total': t,\r\n          'days': days,\r\n          'hours': hours,\r\n          'minutes': minutes,\r\n          'seconds': seconds\r\n        };\r\n        }\r\n\r\n        function getZero(num) { // делаем функцию помощник  эта функция нужна для того чтобы мы подставляли ноль к часам и минутам на странице\r\n          if(num >= 0 && num <10) {\r\n            return ` 0${num}`;\r\n          }else {\r\n            return num;\r\n          }\r\n        }\r\n      function setClock(selector, endtime) {  // делаем функцию для запуливания нашего таймера на страницу \r\n        const timer = document.querySelector(selector), // передаем аргументов селектор чтобы наша функция могла использоваться по всей странице(в селектор будет передаваться элемент со страницы где должен будет отображен таймер)\r\n              days = timer.querySelector('#days'),  // забиваем сюда наши уникальные айди со страницы\r\n              hours = timer.querySelector('#hours'),\r\n              minutes = timer.querySelector('#minutes'),\r\n              seconds = timer.querySelector('#seconds'),\r\n              timeInterval = setInterval(updateClock,1000); // создаем сет интервал который будет запускать функцию апдейтклок каждую секунду\r\n          updateClock(); // сюда мы вставляем апдейт клок для того чтобы не моргала наша верстка так как мы при запуске сначало выполнится весь сет клок потом только апдейт\r\n          // мы же сразу запустим апдейт клок после сетклок после ее выполнения она удалится и и все будет работать без моргания в верстке\r\n        function updateClock (){\r\n          const t = getTimeRemaining(endtime);  // вызываем нашу функцию с полученным значением наших дней часов и т.д.\r\n          days.innerHTML = getZero(t.days); //  с помощью иннера ХТМЛ мы мы присваиваем нашим полученным селекторам значения из функции гетТаймРемейнинг\r\n          hours.innerHTML = getZero(t.hours);\r\n          minutes.innerHTML = t.minutes;\r\n          seconds.innerHTML = t.seconds;\r\n\r\n\r\n          if (t.total <=0){ // если время вышло (идет в отрицательную сторону) останавливаем таймер\r\n            clearInterval(timeInterval);\r\n          }\r\n        }\r\n      }\r\n    setClock(id, deadline);\r\n\r\n}\r\n\r\nexport default timer;","const postData = async (url, data) => { //пишем функцию для взаимодействия с беком\r\n    //передаем аргументы url и data которые будут означать путь и данные которые мы хотим запостить\r\n  //что важно про этот код знать\r\n  //есть такие плюшки восьмого стандарта как async/await которые позволяют асинхронный код сделать наподобии синхронного или проще сказать поставить на паузу определенные действия\r\n  //переменной резалт присвоется значения промисса фетч еще до ответа с сервера что плохо также функция постдата вернет переменную ресалт которая будет undefined\r\n  //поэтому мы юзаем async/await важно понимать где их ставить асинк мы поставили перед началом всей функции а вот эвайт мы поставили перед присвоением значения переменной\r\n  //эвайт ставим там где хотим дождаться ответа от асинхронного кода\r\n      const res =  await fetch(url, {\r\n        method: 'POST',\r\n        headers: {\r\n          'Content-type':'application/json'\r\n        },\r\n        body: data\r\n      });//наша функция получает какие либо данные после чего их фетчит и после в переменную рес будет записан ответ от сервера\r\n      //который мы вернем в формате джейсон\r\n      return await res.json(); //рес будет промисом и возвращаться будет промисс который мы в дальнейшем обработаем\r\n  };\r\n\r\n\r\n  const getResource = async (url) => { //функция для получения данных с сервера \r\n    //тут просто мы аргументом передаем юрл в последствии с помощью фетча мы переходим по этому\r\n    //юрлу и возвращаем ответ от сервера в формате json\r\n      const res =  await fetch(url); //теперь будем вспоминать \r\n      if(!res.ok){\r\n        throw new Error(`Cold not fetch ${url}, status${res.status}`);\r\n      }\r\n      return await res.json(); \r\n  };\r\n\r\n  export{postData};\r\n  export{getResource};\r\n\r\n\r\n  ","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","'use strict';\r\nimport tabs  from './modules/tabs';\r\nimport modal from './modules/modal';\r\nimport timer  from './modules/timer';\r\nimport cards from  './modules/cards';\r\nimport forms  from './modules/forms';\r\nimport slider from  './modules/slider';\r\nimport calc  from './modules/calc';\r\nimport { showModal } from './modules/modal';\r\n\r\n\r\n\r\nwindow.addEventListener('DOMContentLoaded', () => { // DOMCONTENTLOADED ждет пока весь контент в браузере загрузится\r\n    // ниже полкючаем наши файлы джс с помощью синтаксиса команд джс и это все будут функции\r\n    const modalTimerId = setTimeout(() => showModal('.modal', modalTimerId),3000);  \r\ntabs('.tabheader__item', '.tabcontent', '.tabheader__items', 'tabheader__item_active');\r\nmodal('[data-modal', '.modal', modalTimerId);\r\ntimer('.timer','2023-12-12');\r\ncards();\r\nforms('form', modalTimerId);\r\nslider( {\r\n    container: '.offer__slider',\r\n    slide: '.offer__slide',\r\n    nextArrow: '.offer__slider-next',\r\n    prevArrow: '.offer__slider-prev',\r\n    totalCounter: '#total',\r\n    currentCounter: '#current',\r\n    wrapper: '.offer__slider-wrapper',\r\n    field: '.offer__slider-inner'\r\n    \r\n});\r\ncalc();\r\n});\r\n\r\n\r\n\r\n\r\n        \r\n \r\n\r\n\r\n\r\n\r\n//есть второй способ добавление айтем на страницу без классов так называемая верстка на лету\r\n// getResource('http://localhost:3000/menu')\r\n//   .then(data => creatCard(data));\r\n\r\n// function creatCard(data) {\r\n//   data.forEach(({img,altimg, title, descr, price}) => {\r\n//     const element = document.createElement('div');\r\n\r\n//     element.classList.add('menu__item');\r\n//     element.innerHTML = `\r\n//     <img src = \"${img}\" alt =\"${altimg}\"></img> \r\n//         <h3 class=\"menu__item-subtitle\">${title}</h3>\r\n//         <div class=\"menu__item-descr\">${descr}</div>\r\n//         <div class=\"menu__item-divider\"></div> // этот метод тоже имеет место быть тут нет контекста вызова и код вроде как будет поменьше чем через классы\r\n //здесь у нас нет шаблонизации этот метод тоже часто испольуетя и его лушче юзать когда только один раз нам нужно сделать карточки\r\n//         <div class=\"menu__item-price\">\r\n//               <div div class=\"menu__item-cost\">Цена:</div>\r\n//               <div class=\"menu__item-total\"><span>${price}</span> грн/день</div>\r\n//             </div>\r\n//     `;\r\n//   });\r\n// }\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n  \r\n\r\n"],"names":[],"sourceRoot":""}